- [**ROADMAP FULLSTACK PYTHON DEVELOPER**](#roadmap-fullstack-python-developer)
- [**Python**](#python)
  - [Переменные](#переменные)
  - [Базовые типы данных](#базовые-типы-данных)
    - [Числа int/float](#числа-intfloat)
      - [Числа и операции над ними](#числа-и-операции-над-ними)
    - [Списки](#списки)
      - [Двумерные списки](#двумерные-списки)
      - [Списки и операции над ними](#списки-и-операции-над-ними)
    - [Кортежи и операции над ними](#кортежи-и-операции-над-ними)
    - [Множества](#множества)
      - [Множества и операции над ними](#множества-и-операции-над-ними)
    - [Словари](#словари)
      - [Словари и операции над ниди](#словари-и-операции-над-ниди)
  - [Циклы](#циклы)
    - [Цикл for](#цикл-for)
    - [Цикл while](#цикл-while)
  - [Функции](#функции)
    - [Пространство имён](#пространство-имён)
    - [Замыкания](#замыкания)
    - [Функция sorted](#функция-sorted)
    - [lambda функции](#lambda-функции)
    - [Рекурсия](#рекурсия)
    - [Функция map](#функция-map)
    - [Функция filter](#функция-filter)
    - [Функция zip](#функция-zip)
    - [Функции all и any](#функции-all-и-any)
  - [Аннотирование типов. Модуль typing.](#аннотирование-типов-модуль-typing)
    - [Docstring](#docstring)
  - [Стек](#стек)
  - [ООП](#ооп)
    - [Инкапсуляция](#инкапсуляция)
  - [Регулярные выражения](#регулярные-выражения)
    - [Функции регулярных выражений](#функции-регулярных-выражений)
    - [Метасимволы регулярных выражений](#метасимволы-регулярных-выражений)
    - [Флаги регулярных выражений](#флаги-регулярных-выражений)
  - [Итераторы](#итераторы)
  - [Генераторы](#генераторы)
  - [Паттерны проектирования](#паттерны-проектирования)
    - [Декораторы](#декораторы)
  - [Веб-скрапинг](#веб-скрапинг)
    - [Библиотеки для веб-скрапинга](#библиотеки-для-веб-скрапинга)
  - [Виртуальное окружение](#виртуальное-окружение)
  - [Фреймворки](#фреймворки)
    - [Django](#django)
      - [БД, SQL и ORM](#бд-sql-и-orm)
      - [Миграции](#миграции)
    - [Flet](#flet)
    - [Pytest](#pytest)
  - [HTTP запросы](#http-запросы)
  - [Библиотеки](#библиотеки)
    - [loggin](#loggin)
- [GIT](#git)
- [HTML](#html)
- [CSS](#css)
- [Вопросник](#вопросник)
  - [Python](#python-1)
  - [HTML](#html-1)
  - [CSS](#css-1)
  - [JavaScript](#javascript)

# **ROADMAP FULLSTACK PYTHON DEVELOPER**
# **Python**

Python - является высокоуровневым интепретируемым кроссплатформенным динамически строго типизированным языком программирования. Динамическая типизация - это не изменение самой переменной, а перенаправление ссылки, на другой объект.

## Переменные

Переменная - это ссылка на пространство в мамяти, в котором находится некоторый объект. Объекты же - это хранилище данных, имеющие определенный тип данных и имеющие набор свойств и методов. Название переменной может состоять из букв, цифр, нижнего подчеркивания, но не может состоять только из цифр, не может начинаться с цифр и каких либо знаков припенания.

## Базовые типы данных
### Числа int/float
#### Числа и операции над ними
`abs()` - находит модуль числа и принимает на вход одно значение. Модуль числа - это абсолютная величина, то есть, грубо говоря, модуль числа отбрасывает знак.

`min()` - принимает на вход несколько значений через запятую и находит самое наименьшее из них.

`max()` - принимает на вход несколько значений через запятую и находит самое наибольшее из них.

`pow()` - принимает на вход 2 значения и возводит первое число в степень второго.

`round()` - принимает на вход значение и выполняет округление по умолчанию до целого числа. Также, если через запятую указать разряд, то функция будет округлять именно до этого разряда.

### Списки

Список - это упорядоченный набор элементов, каждый их которых имеет свой индекс, позволяющий быстро к нему обратиться. В списке можно хранить различные типы данных.

Индекс - это порядковый номер элемента в списке, начинающийся с 0.

С помощью индексов вохможно менять значение в списке. Пример: `list[3] = 'Pavel'`

Так же возможно получать элементы списка с помощью срезов.

Срез - это извлечение из данного списка одонго или нескольких фрагментов. `list[start, stop, step]`

#### Двумерные списки
`Двумерные списки` - это список, каждый элемент которого является одномерным списком

#### Списки и операции над ними

- `append()` - добавляет элемент в конец списка.
- `extend()` - добавляет в указанный список переданные элементы в список
- `len()` - позволяет узнать количество элементов в списке
- `insert()` - добавляет указанный элемент по указанному индексу. При этом соседние элемента массива сдвигаются вправую сторону
- `remove()` - удаляет элемент по значению и если нет элемента возвращает ValueError
- `pop()` - удаляет элемент по индексу, при этом возвращая значение. Если не передать значение в метод, тогда удаляет последний элемент в списке.
- `clear()` - полностью очищает список, удаляя из него все элементы
- `index()` - возвращает индекс указанного элемента, если элемента нет в списке возвращает ValueError
- `sort()` - позволяет сортировать данный список, без создания нового

### Кортежи и операции над ними

### Множества

#### Множества и операции над ними

`a.intersection(b)` - возвращает пересечение множеств a и b (является аналогом записи a & b ), в которое входят элементы, присутствующие в первом из оригинальных множеств и во втором.

### Словари

`Словарь` - это неупорядоченная структура данных, элементамти которой является пары ключ:значение. Значения ключей уникальны и не могут повторяться. Ключом словаря может быть любой неизменяемый тип данных. А в значение словаря можно записывать любой тип данных.

#### Словари и операции над ниди

Чтобы добавить новую пару в словарь и так же можно менять значение по ключу, нужно:

```
translator['tester'] = 'тестировщик'
```

- `del dict[key]` - удаляет элемент словаря по его ключу
- `pop()` - удаляет элемент словаря по его ключу, возвращая его значение
- `keys()` - возвращает список ключей словаря
- `values()` - возвращает список значений словаря
- `items()` - возвращает список кортежей всех пар ключей:значения словаря

## Циклы

Цикл - это конструкция, которая помогает выполнить определенный блок кода несколько раз.

`Итерация` - это одно повторение блока кода в цикле.

`break` -  команда прерывает работу цикла и выходит из цикла.
`continue` - команда пропускает текущую итерацию цикла и переходит к следующей итерации.

### Цикл for

`for` - счетный, повторяет блок кода определенное количество раз

`range(start, stop, step)` - генерирует список чисел от 0 до указанного числа (не включительно) и передает эти значения в переменную цикла. Задает количество итераций в цикле

### Цикл while

`while` - условный, повторяет блок кода до наступления определенного условия

## Функции

`Функция` - это фрагмент кода, который выполняет определенные операции и отдаёт результат. Пишем один раз, а вызываем сколько нам угодно.

Функции помогают избавиться от дублирования кода. А так же повысить читаемость и чистоту кода.

Принцип DRY (Don’t Repeat Yourself — «Избегай самоповтора») — один из основных принципов разработки ПО, который наставляет нас избегать дублирования кода путём применения различных инструментов и навыков.

- Процедурное программирование. Программа без функций, которая выполняется последовательно сверху вниз.
- Функциональное программирование. Программа, которая содержит функции, но всё ещё является процедурным кодом. Однако такой код более компактный, поскольку вся функциональность вынесена за скобки — в функции.

Параметры — это переменные, которые перечислены в определении функции. Они действуют в качестве «заполнителей» для значений, которые будут использоваться в функции.

Аргументы — это конкретные значения, которые передаются в функцию при её вызове.

### Пространство имён

`Пространство имён` (или namespace, на практике часто мелькает английское слово) — это система, используемая для уникальной идентификации каждого объекта в программе Python. Другими словами, это набор пар [имя -> объект], где имя уникально в пределах пространства имён и ассоциировано с определённым объектом. В целом пространства имён позволяют избегать конфликтов между этими именами.

- Глобальное пространство имён (Global namespace) — это пространство, в котором хранятся все глобальные переменные и функции. Оно создаётся при запуске интерпретатора Python и действует до тех пор, пока интерпретатор не завершит свою работу.
- Локальное пространство имён (Local namespace) — это пространство, которое создаётся при вызове функции и удаляется после того, как функция возвращает значение. Локальное пространство имён содержит параметры функции и переменные, которые объявляются внутри тела функции.
- Встроенное пространство имён (Built-in namespace) — это специальное пространство имён, которое создаётся при запуске интерпретатора Python и содержит все встроенные функции и исключения. Это пространство доступно в любой области видимости.

Область видимости и пространство имён — взаимозаменяемые понятия. В сторонних источниках вы можете увидеть различные варианты терминов. Просто имейте в виду, что когда речь идёт о локальной области видимости — говорится о локальном пространстве имён, а когда о глобальной области видимости — о глобальном пространстве имён.

Ключевое слово `global` позволяет изменять переменную вне текущей области видимости в Python. global используется для создания глобальной переменной и изменения ее в локальной области видимости.

Ключевое слово `nonlocal` позволяет указать имя переменной, с которой вы хотите работать, на уровень выше относительно локальных областей видимости.

### Замыкания

`Замыкание в Python` — это функция, которая динамически генерируется другой функцией и изменяет или использует значения переменных, которые были созданы внешней функцией.

```
def outer_function(param):
    def inner_function():
        print('Вложенная функция имеет доступ к <{}>'.format(param))
    return inner_function

x1 = outer_function('Some_Parameter_1')
x2 = outer_function('Some_Parameter_2')
x1()
x2()
# Вложенная функция имеет доступ к <Some_Parameter_1>
# Вложенная функция имеет доступ к <Some_Parameter_2>
```

### Функция sorted

`sorted()` - применяется для сортировки итерируемых объектов.
```
sorted(iterable, *, key=None, reverse=False)
```
Здесь iterable — это собственно итерируемый объект (списки, кортежи, строки, словари и т.д), key — функция, которая служит ключом или основой сортировки, reverse отвечает за порядок сортировки — убывание или возрастание. По умолчанию False — список сортируется в возрастающем порядке.

### lambda функции

`lambda функции` - анонимные функции, которые включают только одно выражение

Основные преимущества лямбда-функций:

- Краткость — лямбда-функции позволяют определить функцию в одной строке кода. Это делает их идеальными для простых операций, не требующих полного определения функции с помощью def.
- Безымянность — лямбда-функции анонимны, то есть не требуют имени для вызова. Это полезно, когда нужно определить функцию на лету для одноразового использования.
- Удобство использования в высших функциях — лямбда-функции могут делать код более читабельным и понятным в контексте высших функций, которые принимают другие функции в качестве аргументов. В Python это, например, map(), filter(), reduce(), и sorted().

### Рекурсия

`Рекурсивная функция` - это метод, при котором функция вызывает саму себя, обычно с измененными аргументами.

`Рекурсия` — это определение, описание, изображение какого-либо объекта или процесса внутри самого этого объекта или процесса.

`Базовый случай` — это условие, при котором рекурсия останавливается. Он всегда должен быть определён в рекурсивной функции. Без него она будет продолжаться бесконечно, достигая максимальной глубины и приводя к ошибке переполнения стека (RecursionError).

`Рекурсивный случай` — это часть функции, где происходит вызов самой функции.

```
def recursive_func(n=0):
   print('Вывод до запуска рекурсии: ', n)
   if n < 3:
       recursive_func(n + 1)
   print('Вывод после запуска рекурсии: ', n)


recursive_func()
# Вывод до запуска рекурсии:  0
# Вывод до запуска рекурсии:  1
# Вывод до запуска рекурсии:  2
# Вывод до запуска рекурсии:  3
# Вывод после запуска рекурсии:  3
# Вывод после запуска рекурсии:  2
# Вывод после запуска рекурсии:  1
# Вывод после запуска рекурсии:  0
```

### Функция map

`map` - принимает функцию и один или более итерабельных объектов, затем применяет данную функцию ко всем элементам этих объектов и возвращает итератор

```
map(function, iterable, ...)
```

Пример работы:

```
squared = map(lambda x: x**2, [1, 2, 3, 4])

print(list(squared))
# [1, 4, 9, 16]
```

`map()` — функция, предназначенная для применения функции к каждому элементу итерируемого объекта. Это полезный инструмент для быстрой и эффективной обработки коллекций данных без необходимости писать явные циклы.

### Функция filter

`filter` - принимает функцию и итерабельный объект и возвращает итератор их тех элементов итерабельного объекта, для которых функция возвращает `True`

Сигнатура функции:

```
filter(function, iterable)
```

- function — функция, которую нужно применить к каждому элементу итерабельного объекта. Эта функция должна принимать один аргумент и возвращать либо True, либо False.
- iterable — итерабельный объект, элементы которого будут отфильтрованы.

Простой пример использования:

```
numbers = [1, 2, 3, 4, 5, 6]
even_numbers = filter(lambda x: x % 2 == 0, numbers)


print(list(even_numbers))
# [2, 4, 6]
```

В этом примере функция `filter()` применяет анонимную функцию `lambda x: x % 2 == 0` ко всем элементам списка numbers и возвращает итератор из тех элементов, для которых функция возвращает `True` (то есть, из четных чисел).

`filter()` — позволяет фильтровать элементы итерируемого объекта на основе предоставленного условия. Это удобный способ извлечь подмножество данных, соответствующее определенным критериям.

### Функция zip

`zip` - принимает итерируемые объект (как списики или кортежи) в качестве аргументов и возвращает итератор. Этот итератор генерирует кортежи, где i-й кортеж содержит i-й элемент из каждого из переданных итерируемых объектов.

```
zip(*iterables)
```

- `*iterables` — итерируемые аргументы.

Пример использования:

```
names = ["Alice", "Bob", "Charlie"]
scores = [85, 90, 88]


paired = zip(names, scores)


print(list(paired))
# [('Alice', 85), ('Bob', 90), ('Charlie', 88)]
```

`zip()` — эффективное средство для объединения двух или более итерируемых объектов. Особенно полезна, когда нужно параллельно итерировать несколько коллекций или объединить их в словарь или другую структуру данных.

### Функции all и any

Функция any() возвращает True, если хотя бы один элемент итерируемого объекта истинен (или, другими словами, имеет значение True). В противном случае возвращает False:

```
values = [False, False, True, False]
result = any(values)
print(result)
# True
```

Функция all() возвращает True, если все элементы итерируемого объекта истинны. Если хотя бы один элемент ложен, возвращает False:

```
values = [False, False, True, True]
result = all(values)
print(result)
# False
```

`any() и all()` — функции, предоставляющие быстрые проверки истинности элементов коллекции. Они полезны для быстрой оценки условий, основанных на содержимом коллекций.

## Аннотирование типов. Модуль typing.

Аннотации функций позволяют явно указывать ожидаемые типы входных данных и тип возвращаемого значения функции. Это дает разработчикам больше информации о функции, что способствует лучшему пониманию кода и его использованию. Аннотации функций способствуют более эффективной коммуникации между разработчиками, упрощают процесс дебаггинга и ускоряют процесс обнаружения ошибок типов данных.

```
def is_valid_email(email: str):
    if type(email) != str:
        return None

    if email.count("@") != 1:
        return False
    local_part, domain_part = email.split("@")
    if not local_part or not domain_part:
        return False
    if domain_part.count(".") != 1:
        return False

    return True
```

Если же ваша версия Python ниже 3.10, то здесь и приходит на помощь модуль typing, при помощи которого мы укажем союз типов:

```
from typing import Union

def calculate_power(base: Union[int, float], exponent: Union[int, float]) -> Union[int, float]:
    return base ** exponent
```

Если вы пользуетесь версией Python, предшествующей 3.9, то можете воспользоваться модулем typing путем импортированием оттуда Dict:

```
from typing import Dict

def count_letters(word_list: Dict[str, int]) -> Dict[str, int]:
	letter_count = {}
	for word in word_list:
    	for letter in word:
        	if letter in letter_count:
            	letter_count[letter] += 1
        	else:
            	letter_count[letter] = 1
	return letter_count
```

Один из параметров функции может сама являться функция, что тоже можно указать при помощи аннотации, с чем поможет модуль typing:

```
from typing import Callable

def apply_function(f: Callable[[int], str], x: int) -> str:
    return f(x)
```

### Docstring

Документирование функций с помощью docstrings также важный элемент эффективного использования функций в Python. Docstrings дают нам возможность объяснить, что делает функция, какие аргументы она принимает, что она возвращает и какие ошибки может вызвать. Когда аннотации функций используются вместе с docstrings, они предоставляют детальное, понятное и полезное описание функции.

Заключительный и лучший вариант — это добавить в docstring еще более подробное описание параметров:

```
def is_valid_email(email: str) -> bool:
    """
    Check if an email is valid.

    This function takes a string representing an email address, and checks
    if it is formed correctly. An email is considered valid if it contains
    exactly one '@' symbol, and the domain part contains exactly one dot ('.').

    :param email: The email address to check.
    :return: True if the email is valid, False otherwise.
    """
    if email.count("@") != 1:
        return False
    local_part, domain_part = email.split("@")
    if not local_part or not domain_part:
        return False
    if domain_part.count(".") != 1:
        return False

    return True
```

Просматривать документационные строки мы можем прямо в коде (или же в Python Console, что более реалистичный вариант) при помощи функции help():

```
help(is_valid_email)
# Help on function is_valid_email in module __main__:
#
# is_valid_email(email: str) -> bool
#     Check if an email is valid.
#
#     This function takes a string representing an email address, and checks
#     if it is formed correctly. An email is considered valid if it contains
#     exactly one '@' symbol, and the domain part contains exactly one dot ('.').
#
#     :param email: The email address to check.
#     :return: True if the email is valid, False otherwise.
```

## Стек

`Стек` — абстрактный тип данных, представляющий список элементов, организованных по принципу LIFO (англ. last in — first out, «последним пришёл — первым вышел»). Чаще всего принцип работы стека сравнивают со стопкой тарелок: чтобы взять вторую сверху, нужно снять верхнюю. Или с магазином в огнестрельном оружии: стрельба начнётся с патрона, заряженного последним.

Работа со стеком включает в себя следующие операции:
- Добавить в стек (push)
- Взять из стека (pop)
- Вернуть элемент с вершины стека без удаления (peek_back)
- Проверить на пустоту (is_empty)
- Вернуть размер (size)

## ООП

### Инкапсуляция

`Инкапсуляция` — это один из основных принципов объектно-ориентированного программирования (ООП). Это процесс объединения данных и методов, которые работают с этими данными, в одном объекте.

`Цель инкапсуляции` — скрыть внутреннее представление объекта и позволить доступ к нему только через предопределенный набор функций или методов. Это помогает предотвратить случайное или нежелательное изменение внутренних данных объекта.

## Регулярные выражения
Регулярное выражение - это шаблоны, по которым можно проверять валдиность данных, искать совпадения в тексте или заменять определенные фрагменты.
### Функции регулярных выражений
`re.match()` - поиск вхождения шаблона в начале строки. В качестве аргументов требуется передать сначала шаблон, а потом строку для проверки.

`re.search` - ищет первое вхождение шаблона в любом месте строки, возвращает объект match, если в строке есть другие подходящие фрагменты, то они будут проигнорированы. У функции есть дополнительные функции, упрощающие поиск:
- `.group()` - возвращает тот фрагмент строки, в котором нашлось совпадение;
- `.span()` - возвращает кортеж с начальной и конечной позицией искомого шаблона;
- `.string()` - возвращает строку которую передали в re.search().

`re.findall()` - поиск всех вхождение шаблона в любом месте строки

`re.sub()` - заменяет фрагменты в соответствии с шаблоном

`re.split()` - разделяет строку по шаблону, количество разделений задается числом

### Метасимволы регулярных выражений

| Метасимвол | Зачем он нужен                                                                                                                                                    |
| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| .          | Задает один произвольный символ, кромк новой строки                                                                                                               |
| [...]      | Любой символ в скобках, сами символы можно задавать с помощью перечислений или диапазонов                                                                         |
| [^...]     | Любой символ, ислючая указанные в скобках, сами символы можно задавать с помощью перечислений или диапазонов                                                      |
| ^          | Начало строки                                                                                                                                                     |
| $          | Конец строки                                                                                                                                                      |
| \|         | Логический оператор ИЛИ. Поиск одного из нескольких указанных вариантов                                                                                           |
| \          | Экранирование, с помощью которого Python понимает, является ли следующий символ обычным или специальным. Можно обычные символы превращать в метасимволы и обратно |
| *          | Проивольное число повторений одного символа                                                                                                                       |
| ?          | Строго одно повтороение символа                                                                                                                                   |
| +          | Указывает, что предыдущее выражение может повторяться сколько угодно раз, но как минимум один раз                                                                 |
| (...)      | Группировка символов в скобках                                                                                                                                    |
| {...}      | Число повторений предыдущего символа                                                                                                                              |

| Символ | Зачем он нужен                                                                     |
| ------ | ---------------------------------------------------------------------------------- |
| \d     | Любая цифра, заменяет собой запись [0-9]                                           |
| \D     | Исключает все цифры, заменяет собой запись [^0-9]                                  |
| \s     | Любой пробельный символ, включая пробел, табуляцию, новую строку и возврат каретки |
| \S     | Любой символ, исключая пробельный                                                  |
| \w     | Любая буква, цифра и знак нижнего подчеркивания (_)                                |
| \W     | Любой символ, кроме буквы, цифры и нижнего подчеркивания                           |
| \A     | Начало строки, заменяет собой запись ^                                             |
| \Z     | Конец строки, заменяет собой запись $                                              |
| \b     | Начало или конец строки                                                            |
| \B     | Середина слова                                                                     |
| \n     | Новая строки                                                                       |
| \t     | Табуляция                                                                          |
| \r     | Возврат каретки                                                                    |

### Флаги регулярных выражений

| Краткая запись флага | Полная запись флага | Зачем нужен                                                                                                         |
| -------------------- | ------------------- | ------------------------------------------------------------------------------------------------------------------- |
| re.I                 | re.IGNORECASE       | Игнорирует регистр символов                                                                                         |
| re.A                 | re.ASCII            | Возвращает совпадения только по таблице ASCII-символов                                                              |
| re.X                 | re.VERBOSE          | Позволяет использовать комментарии в регулярных выражениях                                                          |
| re.S                 | re.DOTALL           | Метасимвол точка (.) возвращает совпадения по всем символам, включая новую строку.                                  |
| re.L                 | re.LOCALE           | Добавляет к \w, \W, \b, \B, \s и \S региональные настройки, но работает только с байтовыми строками                 |
| re.M                 | re.MULTILINE        | Возвращает совпадения в начале каждой новой строки, если используется с ^, и в конце каждой новой строки — если с $ |

## Итераторы

`Итероваты` - позволяют создавать и работать с последовательностями объектов. Итератор - это объект, который реализует два метода `__iter__()` и `__next__()`. Если в последовательности нет элементов, метод `__next__()` должен вызвать исключение `StopIteration`

- `__iter__()` - возвращает сам итератор
- `__next__()` - возвращает следующий элемент последовательности

## Генераторы

`Генераторы` - функция, которая возвращает итератор, с помощью которого можно обойти некую последовательность значений. Генератор использует ключевое слово `yield` вместо `return` для возврата значений. Когда функция-генератор вызывается, она не выполняет свое тело сразу, а возвращает объект генератор и возвращает значения по мере их генерации.

- `yield` - используется для создания функции-генераторов, которые возвращают итератор. `return` останавливает выполнение тела функции на всегда, а `yield` приостанавливает выполнение, до её возобновления посредством `next()`

## Паттерны проектирования

(Ссылка на паттерны проектирования)[https://refactoring.guru/ru/design-patterns]

### Декораторы

`Декораторы` - это функция, которая позволяет модифицировать и расширять поведение функций и методов, не меняя их код .

`Декоратор` — это функция, которая принимает ссылку на другую функцию и каким-либо образом изменят её поведение.

**Упрощённый пример:**

```
def decorator(func):
    def wrapper(*args, **kwargs):
        print("Делаем что-то перед вызовом функции -- изменяем её поведение")
        res = func(*args, **kwargs)
        print("Делаем что-то после вызова функции -- изменяем её поведение")
        return res + ' + Изменяем возвращаемое значение в wrapper'
    return wrapper

def demo_func(parameter1, parameter2):
    print('Работает целевая функция c параметром(-ами):')
    print(parameter1)
    print(parameter2)
    return 'Возвращаемое значение оригинальной функции'


changed_function = decorator(demo_func)

result = changed_function('Параметр декорированной функции_1',
                'Параметр декорированной функции_2')
print(result)

# Делаем что-то перед вызовом функции -- изменяем её поведение
# Работает целевая функция c параметром(-ами):
# Параметр декорированной функции_1
# Параметр декорированной функции_2
# Делаем что-то после вызова функции -- изменяем её поведение
# Возвращаемое значение оригинальной функции + Изменяем возвращаемое значение в wrapper
```

На самом деле, создание измененной функции путем вызова декоратора — не самый удобный и не общепринятый способ обертывания функций декоратором.

В Python есть специальный оператор «@» при помощи которого мы можем обернуть функцию декоратором прямо в её объявлении:

```
def decorator(func):
    def wrapper(*args, **kwargs):
        print("Отработал декоратор")
        res = func(*args, **kwargs)
        return res
    return wrapper

@decorator
def demo_func():
    print('Отработала оригинальная функция')

demo_func()

# Отработал декоратор
# Отработала оригинальная функция
```

## Веб-скрапинг

`Веб-скрапинг` - это процесс извлечения данных из веб-страниц путем скачивания и анализа их содержимого.

### Библиотеки для веб-скрапинга

1. [BeautifulSoup](https://www.crummy.com/software/BeautifulSoup/bs4/doc.ru/bs4ru.html) - ссылка на документацию
    - `pip install beautifulsoup4`
    - Особенности: превосходный парсер HTML/XML, простой интерфейс веб-скрейпинга, гибкая навигация и поиск.
    - `find_all()` - метод, просматривает и извлекат всех потомков тега, которые соответствуют переданным фильтрующим аргументам
    - `find()` - метод, который ищет первый элемент, удовлетворяющий заданным критериям, в дереве элементов HTML DOM. Если такой элемент не найден, возвращает None.
2. [Scary](https://scrapy.org/) - ссылка на документацию
    - `pip install scrapy`
    - Особенности: быстрая и масштабируемая, middleware, функция распределённого скрейпинга.
3. [Selenium](https://www.selenium.dev/documentation/overview/) - ссылка на документацию
    - `pip install selenium`
    - Особенности: полная автоматизация браузера, работа с сайтами с большим объёмом javascript.
4. [lxml](https://lxml.de/) - ссылка на документацию
    - `pip install lxml`
    - Особенности: очень быстрый парсер XML и HTML
5. [pyquery](https://pythonhosted.org/pyquery/) - ссылка на документацию
    - `pip install pyquery`
    - Особенности: синтаксис в стиле jQuery для доступа к HTML-элементам.

## Виртуальное окружение

Команды Window:
- `venv\Scripts\activate` - запуск виртуального окружения

Команды Mac:
- `source venv/bin/activate` - запуск виртуального окружения

Команды Linux:
- `source venv/bin/activate` - запуск виртуального окружения

## Фреймворки

### Django

[Официальный сайт Django](https://www.djangoproject.com/)

`django` - это высокоуровневый фреймворк для создания высокопроизводительных web приложений на языке python, а именно создание серверной части приложения

**Команды:**
- `pip install django` - устанавливает библиотеку
- `django-admin startproject <имя проекта>` - создает проект
- `python manage.py startapp <имя приложения>` - создаёт приложение проекта
- `python manage.py runserver` - запуск проекта
- `python manage.py makemigrations` - создает миграцию
- `python manage.py migrate` - применяет миграцию
- `python manage.py sqlmigrate [название папки] [номер файла миграциии]` - дает возможность просмотреть запрос на языке sql

#### БД, SQL и ORM
Джанго построен на MTV (Modelds, Templates, Views)

ORM (Object-Relational Mapping)

#### Миграции
Миграции - создают таблицы в базе данных, а так же меняет существующую.

Команда `python manage.py makemigrations` - создает миграцию

Команда `python manage.py migrate` - применяет миграцию

Команда `python manage.py sqlmigrate [название папки] [номер файла миграциии]` - дает возможность просмотреть запрос на языке sql

### Flet
[Ссылка на документацию](https://flet.dev/docs/)

- Команда `pip install flet` - устанавливает библиотеку
- Команда `flet --version` - узнать какая версия установлена
- Команда `flet create <имя проекта>` - содает новый проект
- Команда `flet run <имя файла>` - запускает программу
- Команда `flet run --web <имя файла>` - запускат приложение как web-приложение

### Pytest

Pytest - это фреймворк для тестирования кода на языке Python.

- Команда `pip install -U pytest` - установка Pytest
- Команда `pytest` - запускает тессты текущего католога
- Команда `pytest <имя файла.py>` - запускает файл с тестами
<!-- - Команда `pytest <имя файла.py>;<имя функции>` - запускает проверку функции -->

Чтобы Pytest воспринимал функции тестовыми, файлы и сами тесты должны быть названы определенным образом:
- **название файла** должно начинаться с `test` или заканчиваться на `test.py`
- **название функции** должно быть аписано в нижнем регистре и начинаться с `test_`

`assert()` - отвечает за результат тестирования. Если заданное после него условие правдиво — тест пройден, если оно ложно оператор assert вызывает исключение AssertionError, что приводит к остановке выполнения программы

`Фикстуры` - это функции, которые создают окружение вокруг тестов. Они удобны, когда нужно передать один и те же входные данные нескольким тестам.

`Финализатор` -

## HTTP запросы
- GET - получение ресурса
- POST - создание ресурса
- PUT - обновление ресурса
- DELETE - удаление ресурса
- OPTIONS - доступные запросы
- HEAD - получение заголовков
- PATCH - обновление части ресурса

## Библиотеки

### loggin
`import login` - это набор функций и классов, которые позволяют регистрировать события, происходящие во время работы кода.

Основная функция, которая пригодится Вам для работы с этим модулем — basicConfig(). В ней Вы будете указывать все основные настройки (по крайней мере, на базовом уровне).

У функции basicConfig() 3 основных параметра:

- level — уровень логирования на Python;
- filename — место, куда мы направляем логи;
- format — вид, в котором мы сохраняем результат.

# GIT

**Слияние веток**
1. Перейдите к ветке master: git checkout master.
2. Обновите локальную ветку с сервера: git pull origin master.
3. Выполните команду: git merge merged-branch. где merged-branch — имя сливаемой ветки. Сливаемой веткой считается та, из которой берутся изменения.

# HTML
HTML (Hyper Text Markup Language) - язык гиппертекстовой разметки. Определяет структуру вашего контента.

Любой документ на языке HTML представляет собой набор элементов, причем начало и конец каждого элемента обозначается специальными пометками - тегами.

Структурные элементы - `<html>, <head>, <body>`

Текстовые элементы - `<h1><h6>, <p>, <span>, <a>`

Строчные элементы - `<strong>, <em>, <br>, <img>`

Блочные элементы - `<div>`

# CSS
CSS (Cascading Style Sheets) - каскадные таблицы стилей. Формальный язык описания внешнего вида документа написанного с использованием языка разметки

```
селектор {
  свойство: значение;
}
```
Селекторы бывают элементов, по ID, класса, по атрибуту, псевдокласса.

Псевдоклассы
- `:hover` -
- `:active` -
- `:focus` -
- `:visited` -****
- `:nth-child(n)` -
- `:first-child` -
- `:last-child` -
- `:nth-of-type(n)` -
- `:not(highlight)` -

Псевдоэлементы
- `::defore` -
- `::after` -
- `::first-line` -
- `::first-letter` -
///

# Вопросник
## Python
## HTML
## CSS
## JavaScript
